// Generated by CoffeeScript 1.3.3
/*global require, d3
*/

require(['d3', 'd3layout'], function() {
  "use strict";

  var diagonal, h, i, m, root, toggle, tree, update, vis, w;
  update = function(source) {
    var duration, link, node, nodeEnter, nodeExit, nodeUpdate, nodes;
    duration = (d3.event && d3.event.altKey ? 5000 : 500);
    nodes = tree.nodes(root).reverse();
    nodes.forEach(function(d) {
      return d.y = d.depth * 180;
    });
    node = vis.selectAll("g.node").data(nodes, function(d) {
      return d.id || (d.id = ++i);
    });
    nodeEnter = node.enter().append("svg:g").attr("class", "node").attr("transform", function() {
      return "translate(" + source.y0 + "," + source.x0 + ")";
    }).on("click", function(d) {
      toggle(d);
      return update(d);
    });
    nodeEnter.append("svg:circle").attr("r", 1e-6).style("fill", function(d) {
      if (d._children) {
        return "lightsteelblue";
      } else {
        return "#fff";
      }
    });
    nodeEnter.append("svg:text").attr("x", function(d) {
      if (d.children || d._children) {
        return -10;
      } else {
        return 10;
      }
    }).attr("dy", ".35em").attr("text-anchor", function(d) {
      if (d.children || d._children) {
        return "end";
      } else {
        return "start";
      }
    }).text(function(d) {
      return d.name;
    }).style("fill-opacity", 1e-6);
    nodeUpdate = node.transition().duration(duration).attr("transform", function(d) {
      return "translate(" + d.y + "," + d.x + ")";
    });
    nodeUpdate.select("circle").attr("r", 4.5).style("fill", function(d) {
      if (d._children) {
        return "salmon";
      } else {
        return "#fff";
      }
    });
    nodeUpdate.select("text").style("fill-opacity", 1);
    nodeExit = node.exit().transition().duration(duration).attr("transform", function() {
      return "translate(" + source.y + "," + source.x + ")";
    }).remove();
    nodeExit.select("circle").attr("r", 1e-6);
    nodeExit.select("text").style("fill-opacity", 1e-6);
    link = vis.selectAll("path.link").data(tree.links(nodes), function(d) {
      return d.target.id;
    });
    link.enter().insert("svg:path", "g").attr("class", "link").attr("d", function() {
      var o;
      o = {
        x: source.x0,
        y: source.y0
      };
      return diagonal({
        source: o,
        target: o
      });
    }).transition().duration(duration).attr("d", diagonal);
    link.transition().duration(duration).attr("d", diagonal);
    link.exit().transition().duration(duration).attr("d", function() {
      var o;
      o = {
        x: source.x,
        y: source.y
      };
      return diagonal({
        source: o,
        target: o
      });
    }).remove();
    return nodes.forEach(function(d) {
      d.x0 = d.x;
      return d.y0 = d.y;
    });
  };
  toggle = function(d) {
    if (d.children) {
      d._children = d.children;
      return d.children = null;
    } else {
      d.children = d._children;
      return d._children = null;
    }
  };
  m = [20, 120, 20, 120];
  w = 1130 - m[1] - m[3];
  h = 1000 - m[0] - m[2];
  i = 0;
  root = void 0;
  tree = d3.layout.tree().size([h, w]);
  diagonal = d3.svg.diagonal().projection(function(d) {
    return [d.y, d.x];
  });
  vis = d3.select("#riskTree").append("svg:svg").attr("width", w + m[1] + m[3]).attr("height", h + m[0] + m[2]).append("svg:g").attr("transform", "translate(" + m[3] + "," + m[0] + ")");
  return d3.json("flare.json", function(json) {
    var toggleAll;
    toggleAll = function(d) {
      if (d.children) {
        d.children.forEach(toggleAll);
        return toggle(d);
      }
    };
    root = json;
    root.x0 = h / 2;
    root.y0 = 0;
    root.children.forEach(toggleAll);
    toggle(root.children[1]);
    toggle(root.children[1].children[2]);
    toggle(root.children[9]);
    toggle(root.children[9].children[0]);
    return update(root);
  });
});
